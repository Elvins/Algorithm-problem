/**
分饼干
易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值

输入描述:
输入包括两行：
第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位)
第二行为小朋友的人数n

输出描述:
输出k可能的数值种数，保证至少为1

输入例子:
9999999999999X
3

输出例子:
4


坑：n的范围未知，故余数的个数未知
**/

#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    int n;
    cin >> s;
    cin >> n;
    
    //动态规划：dp[a][b]表示在a位余数为b时的数值种树
    long long dp[20][10001];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for(int i = 1; i <= s.size(); i++) //从前往后迭代
    {
        for(int j = 0; j < n; j++) //所取值余数的可能性
        {
            for(int k = 0; k < 10; k++) //这一位所能取的数
            {
                if(s[i-1]>='0' && s[i-1]<='9' && s[i-1]-'0'!=k) 
                {
                    continue; //若是x计算所有可能取值，若不是就计算当前这一种取值
                }
                int t = (j * 10 + k) % n;//计算当前值和前一位余数的取值组合所产生的余数
                dp[i][t] += dp[i-1][j];//迭代为下一位做准备
            }
        }
    }
    cout << dp[s.size()][0] << endl;//最后一位余数为0的取值
    
    return 0;
}