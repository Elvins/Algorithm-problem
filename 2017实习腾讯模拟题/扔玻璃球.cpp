/**
一道关于动态规划的面试题——Google面试题：扔玻璃珠某幢大楼有100层。
你手里有两颗一模一样的玻璃珠。当你拿着玻璃珠在某一层往下扔的时候，一定会有两个结果，玻璃珠碎了或者没碎。这幢大楼有个临界楼层。低于它的楼层，往下扔玻璃珠，玻璃珠不会碎，等于或高于它的楼层，扔下玻璃珠，玻璃珠一定会碎。玻璃珠碎了就不能再扔。现在让你设计一种方式，使得在该方式下，最坏的情况扔的次数比其他任何方式最坏的次数都少。也就是设计一种最有效的方式。首先，为了保存下一颗玻璃珠自己玩，就采用最笨的办法吧：从第一层开始试，每次增加一层，当哪一层扔下玻璃珠后碎掉了，也就知道了。不过最坏的情况扔的次数可能为100。
当然，为了这一颗玻璃珠代价也高了点，还是采取另外一种办法吧。随便挑一层，假如为N层，扔下去后，如果碎了，那就只能从第一层开始试了，最坏的情况可能为N。假如没碎，就一次增加一层继续扔吧，这时最坏的情况为100-N。也就是说，采用这种办法，最坏的情况为max{N, 100-N+1}。之所以要加一，是因为第一次是从第N层开始扔。不过还是觉得不够好，运气好的话，挑到的N可能刚好是临界楼层，运气不好的话，要扔的次数还是很多。不过回过头看看第二种方式，有没有什么发现。假如没摔的话，不如不要一次增加一层继续扔吧，而是采取另外一种方式：把问题转换为100-N，在这里面找临界楼层，这样不就把问题转换成用递归的方式来解决吗？
看下面：
假如结果都保存在F[101]这个数组里面，那么：
F[N]=100-N，
F[100]=min（max（1，1+F[N-1]），max（2，1+F[N-2]），……，max（N-1，1+F[1]））;
**/
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
using namespace std;

int dp[101] = { 0 };

void solve()
{
    int i , j , k;
    for(i = 2 ; i < 101 ; ++i)
    {
        dp[i] = i;
        for(j = 1 ; j < i ; ++j)
        {
            k = (j>=(1 + dp[i-j])) ? j : (1 + dp[i-j]);
            if(dp[i] > k)
            dp[i] = k;
        }
    }
}

int main(void)
{
    dp[0] = 0 , dp[1] = 1;
    solve();
    printf("%d\n",dp[100]);
    return 0;
}